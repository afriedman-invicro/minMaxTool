#include "ipacs.vqs"
// clear all loaded data
var dm = VQ.dataManager();
var mw = VQ.mainWin();
var mm = VQ.minMaxTool();
dm.unloadData(VQ.index(0),-1);
mw.setViewMode('Slice View','Navigation');

// pause sctipt to allow user to load everything in -> wait for them to say "ok"
VQ.suspend('Load in dataset(s), ok when done',false);
var tmp = String(VQ.currentDcmRep());
tmp = tmp.replace('ipacs://:@','ipacss://');
var port = tmp.match(/:\d+/g);
tmp = tmp.replace(port,'');
var url = tmp.slice(0,tmp.indexOf('/customers'));
var proj = tmp.slice(tmp.indexOf('/customers'),tmp.length+1);
var repo = new iPACS(url,proj);



//for now, assume they loaded same number of PT/NM as CT data sets
var nSeries = dm.size();
// set all the CTS to gray scale
//set all the PT/NMs to nih_fire2 

var convUnits = VQ.askYesNoQuestion('Convert units?',false);
if (convUnits){
    setUnits();
}

var ct = [];
var nm = [];
for (var j = 0; j < nSeries; j++){
    if (dm.getDesc(VQ.index(j),'Modality') == 'CT'){
        dm.setPalette(VQ.index(j),'gray'); 
        ct.push(dm.getDesc(VQ.index(j),'StudyInstanceUID'));
    }
    else{
        dm.setPalette(VQ.index(j),'nih_fire2');
        nm.push(dm.getDesc(VQ.index(j),'StudyInstanceUID'))
    }
}

nCTs = ct.length;
nPTs = nm.length;


if (nSeries > (nCTs*2)){
    VQ.suspend('Multiple NMs for one CT - is this intended?')
}


// got to multiview
mw.setViewMode('Multi View','Layout');
var mv = VQ.currentView();


//set up 1 row, number of columns = number of data sets
mv.setLayoutSize(1,nPTs);


//set to sag. panel for all
for (var k = 0; k < nPTs; k++){
    mv.setPlane(1,k,1);
}


// load 1st CT and 1st PT/NM in first panel -> etc for the rest
var counter = 0;
for (var m = 0; m < nSeries; m++){
    if (dm.getDesc(VQ.index(m),'Modality') != 'CT'){
        counter+=1
        mv.setData(0,counter-1,1,m);
       
    }

}
for (var i = 0; i < nPTs; i++){
    mv.setData(0,i,0,ct.indexOf(nm[i]))
}


var rangesGood = false;

while (!rangesGood){
    fixRanges();
    rangesGood = VQ.askYesNoQuestion('CT/NM ranges good to go?',true);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////////
function fixRanges(){
    var ctRangeGood = false;
    var nmRangeGood = false;
    while (!ctRangeGood){
        var ctMinMax = VQ.getValues('Set CT range',{'Min':'text','Max':'text'},false);
        var flag = (parseFloat(ctMinMax['Min']) > parseFloat(ctMinMax['Max']));
        while (flag){
            VQ.showMessage('Please reset - max must be > min!')
            ctMinMax = VQ.getValues('Set CT range',{'Min':'text','Max':'text'},false);
            flag = (parseFloat(ctMinMax['Min']) > parseFloat(ctMinMax['Max']));
        }
        for (var n = 0; n < nCTs; n++){
           dm.setMinMaxCache(VQ.index(n),parseFloat(ctMinMax['Min']),parseFloat(ctMinMax['Max']));
           }
        ctRangeGood = VQ.askYesNoQuestion('Is CT range good to go?',false);
       }
    while (!nmRangeGood){
        var nmMinMax = VQ.getValues('Set NM range', {'Min':'text','Max':'text'},false);
        var flag = (parseFloat(nmMinMax['Min']) > parseFloat(nmMinMax['Max']));
        while (flag){
            VQ.showMessage('Please reset - max must be > min!')
            nmMinMax = VQ.getValues('Set NM range',{'Min':'text','Max':'text'},false);
            flag = (parseFloat(nmMinMax['Min']) > parseFloat(nmMinMax['Max']));
        }
        for (var k = nCTs; k < nSeries; k++){
        dm.setMinMaxCache(VQ.index(k),parseFloat(nmMinMax['Min']),parseFloat(nmMinMax['Max'])); 
           } 
        nmRangeGood = VQ.askYesNoQuestion('Is NM range good to go?',false);
       }

}

function setUnits(){
        var unit = VQ.getValues('NM Units',{'Unit':['%ID/g','SUV']},true);
        if (unit['Unit']=='%ID/g'){
            for (var k = 0; k < nSeries; k++){
                if (dm.getDesc(VQ.index(k),'Modality') != 'CT'){
                    var injDose = repo.getInjectedDose(VQ.index(k));
                    if (injDose==-1) {
                        var strErr = 'Injected dose not found for index ' + k.toString() + '\nPlease input manually'
                        var dose = VQ.getValues(strErr,{'Injected Dose':'text'},false);
                        injDose = parseFloat(dose['Injected Dose']);}
                    preProcessWrapper('-convert', '%ID/g', '-injdose', injDose + ' uCi');
                }
            
            }
            
        }
        else{
            for (var k = 0; k < nSeries; k++){
                if (dm.getDesc(VQ.index(k),'Modality') != 'CT'){
                    var injDose = repo.getInjectedDose(VQ.index(k));
                    if (injDose==-1) {
                        var dose = VQ.getValues('Injected dose not found. \nPlease input manually',{'Injected Dose':'text'},false);
                        injDose = parseFloat(dose['Injected Dose']);
                        }
                    var wt = repo.getWeight(VQ.index(k));
                    if (wt==-1) {
                        var weight = VQ.getValues('Weight not found.Please input manually',{'Weight':'text'},false);
                        wt = parseFloat(weight['Weight']);
                        }
                        preProcessWrapper('-convert', 'SUV', '-injdose', injDose + ' uCi','-weight', wt + ' g');
                }
                
        }
    }
}

function preProcessWrapper(){
    // defaults
    options = {'autoCrop':'false',
               'bedRemoval':'false',
               'calibFactor':'false',
               'calibFactorValue':'NM=1 uCi',
               'coRegister':'false',
               'coRegisterFast':'false',
               'coRegisterVersor':'false',
               'comment':'false',
               'commentText':'pre-p',
               'convertUnit':'false',
               'convertUnitUnit':'uCi',
               'injDose':'0 MBq',
               'qualityControl':'false',
               'resample':'false',
               'resampleVoxSize':'1.0',
               'storeData':'false',
               'weight':'0 g'
    };

    try{
        var i = 0
        while (i < arguments.length){
            switch(arguments[i]){
                case "-ctbedremoval":
                    options['bedRemoval'] = 'true';
                    i++;
                    break;
                case "-coregister":
                    options['coRegister'] = 'true';
                    i++;
                    break;
                case "-coregisterfast":
                    options['coRegisterFast'] = 'true';
                    i++;
                    break;
                case "-coregisterversor":
                    options['coRegisterVersor'] = 'true';
                    i++;
                    break;
                case "-autocrop":
                    options['autoCrop'] = 'true';
                    i++;
                    break
                case "-calibfactor":
                    options['calibFactor'] = 'true';
                    options['calibFactorValue'] = arguments[i+1];
                    i += 2;
                    break;
                case "-resample":
                    options['resample'] = 'true';
                    options['resampleVoxSize'] = arguments[i+1];
                    i += 2;
                    break;
                case "-convert":
                    options['convertUnit'] = 'true';
                    options['convertUnitUnit'] = arguments[i+1];
                    i += 2;
					
					
					//check for unk
					for (var zz = 0; zz<dm.size(); zz++){
						if (dm.getDesc(VQ.index(zz),'Units').toLowerCase()=='unk'){
							VQ.showMessage('UNK units in index '+zz.toString()+'.\nConversion will not apply.')
						}
					}
					
                    break;
                case "-weight":
                    options['weight'] = arguments[i+1];
                    i+=2;
                    break;
                case "-injdose":
                    options['injDose'] = arguments[i+1];
                    i +=2;
                    break;
                case "-desc":
                    options['comment'] = 'true';
                    options['commentText'] = arguments[i+1];
                    i +=2;
                    break;
                case "-qc":
                    options['qualityControl'] = 'true';
                    i++;
                    break;
                case "-store":
                    options['storeData'] = 'true';
                    i++;
                    break;
                default:
                    VQ.debug(sprintf('Argument %s not supported...ignoring',arguments[i]));
                    i++;
            } 
        }
    }
    catch (err){
        VQ.debug("Preprocess Wrapper Error: "+ err);
    }
    // Do actual script
    var opt_array = new Array();
    for (var i in options)
        opt_array.push(i+'='+options[i]);
    var output = opt_array.join('|');
    VQ.preProcess(output);
    return output;
}
